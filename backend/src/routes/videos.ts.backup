import express from 'express';
import multer from 'multer';
import path from 'path';
import { promises as fs } from 'fs';
import { authenticateToken } from '../middleware/auth.js';
import { VideoModel, IVideo } from '../models/Video.js';
import { supabaseAdmin } from '../config/supabase.js';
import { VideoProcessingService } from '../services/videoProcessingService.js';
import { AIService } from '../services/aiService.js';
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [new winston.transports.Console()]
});

const router = express.Router();

// Configure multer for video uploads
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = process.env.UPLOAD_DIR || './uploads';
    await fs.mkdir(uploadDir, { recursive: true });
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage,
  limits: {
    fileSize: 500 * 1024 * 1024, // 500MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['video/mp4', 'video/mov', 'video/avi', 'video/mkv', 'video/webm'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only video files are allowed.'));
    }
  }
});

// Get user's videos
router.get('/', auth, async (req, res) => {
  try {
    const { page = 1, limit = 10, status, search } = req.query;
    const offset = (Number(page) - 1) * Number(limit);

    let query = Video.select('*').eq('user_id', req.user.id);

    if (status) {
      query = query.eq('analysis_status', status);
    }

    if (search) {
      query = query.ilike('title', `%${search}%`);
    }

    const { data: videos, error, count } = await query
      .range(offset, offset + Number(limit) - 1)
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    res.json({
      videos: videos || [],
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total: count || 0,
        pages: Math.ceil((count || 0) / Number(limit))
      }
    });

  } catch (error) {
    logger.error('Failed to fetch videos', { error: error.message, userId: req.user.id });
    res.status(500).json({ error: 'Failed to fetch videos' });
  }
});

// Upload and process video
router.post('/upload', auth, upload.single('video'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No video file provided' });
    }

    const { title, description, platforms = [] } = req.body;

    logger.info('Video upload started', { 
      filename: req.file.filename, 
      size: req.file.size,
      userId: req.user.id 
    });

    // Validate video file
    const isValid = await VideoProcessingService.validateVideoFile(req.file.path);
    if (!isValid) {
      await fs.unlink(req.file.path); // Clean up invalid file
      return res.status(400).json({ error: 'Invalid video file' });
    }

    // Create video record in database
    const { data: video, error } = await Video.insert({
      user_id: req.user.id,
      title: title || req.file.originalname,
      description: description || '',
      filename: req.file.filename,
      original_filename: req.file.originalname,
      file_size: req.file.size,
      file_path: req.file.path,
      url: `/uploads/${req.file.filename}`,
      target_platforms: Array.isArray(platforms) ? platforms : [platforms].filter(Boolean),
      analysis_status: 'pending',
      processing_progress: 0
    }).select().single();

    if (error) {
      await fs.unlink(req.file.path); // Clean up file if database insert fails
      throw error;
    }

    // Start background processing
    processVideoInBackground(video.id, req.file.path);

    res.status(201).json({
      message: 'Video uploaded successfully',
      video: {
        id: video.id,
        title: video.title,
        status: video.analysis_status,
        progress: video.processing_progress
      }
    });

  } catch (error) {
    logger.error('Video upload failed', { error: error.message, userId: req.user?.id });
    
    // Clean up file if it exists
    if (req.file) {
      try {
        await fs.unlink(req.file.path);
      } catch (cleanupError) {
        logger.error('Failed to clean up uploaded file', { error: cleanupError.message });
      }
    }

    res.status(500).json({ error: 'Video upload failed' });
  }
});

// Get video details
router.get('/:id', auth, async (req, res) => {
  try {
    const { data: video, error } = await Video
      .select(`
        *,
        engagement_segments(*),
        hooks(*)
      `)
      .eq('id', req.params.id)
      .eq('user_id', req.user.id)
      .single();

    if (error) {
      throw error;
    }

    if (!video) {
      return res.status(404).json({ error: 'Video not found' });
    }

    res.json({ video });

  } catch (error) {
    logger.error('Failed to fetch video details', { error: error.message, videoId: req.params.id });
    res.status(500).json({ error: 'Failed to fetch video details' });
  }
});

// Get video processing status
router.get('/:id/status', auth, async (req, res) => {
  try {
    const { data: video, error } = await Video
      .select('id, analysis_status, processing_progress, processing_error')
      .eq('id', req.params.id)
      .eq('user_id', req.user.id)
      .single();

    if (error) {
      throw error;
    }

    if (!video) {
      return res.status(404).json({ error: 'Video not found' });
    }

    res.json({
      status: video.analysis_status,
      progress: video.processing_progress,
      error: video.processing_error
    });

  } catch (error) {
    logger.error('Failed to fetch video status', { error: error.message, videoId: req.params.id });
    res.status(500).json({ error: 'Failed to fetch video status' });
  }
});

// Create clip from video
router.post('/:id/clips', auth, async (req, res) => {
  try {
    const { startTime, duration, title, aspectRatio = '9:16', quality = 'high' } = req.body;

    if (!startTime || !duration) {
      return res.status(400).json({ error: 'Start time and duration are required' });
    }

    // Get video details
    const { data: video, error } = await Video
      .select('*')
      .eq('id', req.params.id)
      .eq('user_id', req.user.id)
      .single();

    if (error || !video) {
      return res.status(404).json({ error: 'Video not found' });
    }

    // Create clip
    const clipPath = await VideoProcessingService.createClip(video.file_path, {
      startTime: Number(startTime),
      duration: Number(duration),
      outputFormat: 'mp4',
      quality: quality as 'high' | 'medium' | 'low',
      aspectRatio: aspectRatio as '16:9' | '9:16' | '1:1'
    });

    // TODO: Upload clip to Supabase Storage and save to database
    // For now, return the local path
    
    res.json({
      message: 'Clip created successfully',
      clipPath: clipPath,
      title: title || `Clip from ${video.title}`
    });

  } catch (error) {
    logger.error('Failed to create clip', { error: error.message, videoId: req.params.id });
    res.status(500).json({ error: 'Failed to create clip' });
  }
});

// Get AI analysis results
router.get('/:id/analysis', auth, async (req, res) => {
  try {
    const { data: video, error: videoError } = await Video
      .select('*')
      .eq('id', req.params.id)
      .eq('user_id', req.user.id)
      .single();

    if (videoError || !video) {
      return res.status(404).json({ error: 'Video not found' });
    }

    if (video.analysis_status !== 'completed') {
      return res.status(202).json({ 
        message: 'Analysis still in progress',
        status: video.analysis_status,
        progress: video.processing_progress
      });
    }

    // Get engagement segments and hooks
    const { data: segments } = await Video.select('engagement_segments(*)')
      .eq('id', req.params.id)
      .single();

    const { data: hooks } = await Video.select('hooks(*)')
      .eq('id', req.params.id)
      .single();

    res.json({
      transcript: video.transcript,
      summary: video.summary,
      keywords: video.keywords,
      sentiment: video.sentiment_analysis,
      engagementSegments: segments?.engagement_segments || [],
      hooks: hooks?.hooks || []
    });

  } catch (error) {
    logger.error('Failed to fetch analysis results', { error: error.message, videoId: req.params.id });
    res.status(500).json({ error: 'Failed to fetch analysis results' });
  }
});

// Delete video
router.delete('/:id', auth, async (req, res) => {
  try {
    const { data: video, error } = await Video
      .select('file_path')
      .eq('id', req.params.id)
      .eq('user_id', req.user.id)
      .single();

    if (error || !video) {
      return res.status(404).json({ error: 'Video not found' });
    }

    // Delete file from filesystem
    try {
      await fs.unlink(video.file_path);
    } catch (fileError) {
      logger.warn('Failed to delete video file', { error: fileError.message, path: video.file_path });
    }

    // Delete from database (cascades to related tables)
    const { error: deleteError } = await Video
      .delete()
      .eq('id', req.params.id)
      .eq('user_id', req.user.id);

    if (deleteError) {
      throw deleteError;
    }

    res.json({ message: 'Video deleted successfully' });

  } catch (error) {
    logger.error('Failed to delete video', { error: error.message, videoId: req.params.id });
    res.status(500).json({ error: 'Failed to delete video' });
  }
});

// Background processing function
async function processVideoInBackground(videoId: string, videoPath: string) {
  try {
    logger.info('Starting background video processing', { videoId });

    // Update status to processing
    await Video.update({ 
      analysis_status: 'processing',
      processing_progress: 10
    }).eq('id', videoId);

    // Process video with AI analysis
    const result = await VideoProcessingService.processVideo(videoPath, {
      extractAudio: true,
      generateThumbnails: true,
      analyzeWithAI: true
    });

    if (!result.success) {
      throw new Error(result.error);
    }

    // Update progress
    await Video.update({ processing_progress: 60 }).eq('id', videoId);

    // Store AI analysis results
    if (result.aiAnalysis) {
      const updates: any = {
        transcript: result.aiAnalysis.transcript,
        summary: result.aiAnalysis.summary,
        keywords: result.aiAnalysis.keywords,
        sentiment_analysis: result.aiAnalysis.sentimentAnalysis,
        processing_progress: 80
      };

      // Store video info
      if (result.videoInfo) {
        updates.duration = result.videoInfo.duration;
        updates.width = result.videoInfo.width;
        updates.height = result.videoInfo.height;
        updates.fps = result.videoInfo.fps;
        updates.bitrate = result.videoInfo.bitrate;
      }

      await Video.update(updates).eq('id', videoId);

      // Store engagement segments
      if (result.aiAnalysis.engagementSegments.length > 0) {
        const segmentInserts = result.aiAnalysis.engagementSegments.map(segment => ({
          video_id: videoId,
          start_time: segment.start,
          end_time: segment.end,
          score: segment.score,
          confidence: segment.confidence,
          text_content: segment.text,
          emotions: segment.emotions,
          topics: segment.topics
        }));

        await Video.select('engagement_segments').insert(segmentInserts);
      }

      // Store hooks
      if (result.aiAnalysis.hooks.length > 0) {
        const hookInserts = result.aiAnalysis.hooks.map(hook => ({
          video_id: videoId,
          timestamp: hook.timestamp,
          type: hook.type,
          confidence: hook.confidence,
          description: hook.description,
          text_content: hook.text,
          suggested_clip_start: hook.suggestedClipStart,
          suggested_clip_end: hook.suggestedClipEnd
        }));

        await Video.select('hooks').insert(hookInserts);
      }
    }

    // Mark as completed
    await Video.update({ 
      analysis_status: 'completed',
      processing_progress: 100,
      processed_at: new Date().toISOString()
    }).eq('id', videoId);

    logger.info('Background video processing completed', { videoId });

  } catch (error) {
    logger.error('Background video processing failed', { error: error.message, videoId });
    
    await Video.update({ 
      analysis_status: 'failed',
      processing_error: error.message
    }).eq('id', videoId);
  }
}

export default router; 